import { describe, it, expect, vi, beforeEach } from 'vitest'
import { EventEmitter } from 'node:events'

const { mockExecFileAsync, mockWriteFile, mockSpawn } = vi.hoisted(() => ({
  mockExecFileAsync: vi.fn(),
  mockWriteFile: vi.fn(),
  mockSpawn: vi.fn(),
}))

vi.mock('node:util', () => ({
  promisify: () => mockExecFileAsync,
  default: { promisify: () => mockExecFileAsync },
}))

vi.mock('node:fs/promises', () => ({
  writeFile: mockWriteFile,
  default: { writeFile: mockWriteFile },
}))

vi.mock('node:child_process', () => ({
  default: { execFile: vi.fn(), spawn: mockSpawn },
  execFile: vi.fn(),
  spawn: mockSpawn,
}))

import { GitOperationsManager } from './git-operations'

describe('GitOperationsManager', () => {
  let git: GitOperationsManager

  beforeEach(() => {
    vi.clearAllMocks()
    git = new GitOperationsManager()
  })

  // ---- commit ----

  describe('commit', () => {
    it('calls git add then git commit with correct args', async () => {
      mockExecFileAsync.mockResolvedValue({ stdout: '', stderr: '' })

      await git.commit('/worktree', 'fix: resolve bug')

      expect(mockExecFileAsync).toHaveBeenCalledTimes(2)
      expect(mockExecFileAsync).toHaveBeenNthCalledWith(
        1,
        'git',
        ['add', '.'],
        { cwd: '/worktree' },
      )
      expect(mockExecFileAsync).toHaveBeenNthCalledWith(
        2,
        'git',
        ['commit', '-m', 'fix: resolve bug'],
        { cwd: '/worktree' },
      )
    })

    it('propagates errors from git commit', async () => {
      mockExecFileAsync
        .mockResolvedValueOnce({ stdout: '', stderr: '' }) // git add succeeds
        .mockRejectedValueOnce(new Error('nothing to commit'))

      await expect(git.commit('/worktree', 'empty')).rejects.toThrow('nothing to commit')
    })
  })

  // ---- getAheadBehind ----

  describe('getAheadBehind', () => {
    it('parses rev-list output correctly', async () => {
      mockExecFileAsync.mockResolvedValue({ stdout: '3\t5\n', stderr: '' })

      const result = await git.getAheadBehind('/worktree', 'main')

      expect(result).toEqual({ ahead: 5, behind: 3 })
      expect(mockExecFileAsync).toHaveBeenCalledWith(
        'git',
        ['rev-list', '--left-right', '--count', 'main...HEAD'],
        { cwd: '/worktree' },
      )
    })

    it('handles tab-separated output', async () => {
      mockExecFileAsync.mockResolvedValue({ stdout: '0\t12\n', stderr: '' })

      const result = await git.getAheadBehind('/worktree', 'origin/main')

      expect(result).toEqual({ ahead: 12, behind: 0 })
    })

    it('returns {0,0} on error', async () => {
      mockExecFileAsync.mockRejectedValue(new Error('not a git repo'))

      const result = await git.getAheadBehind('/worktree', 'main')

      expect(result).toEqual({ ahead: 0, behind: 0 })
    })
  })

  // ---- getConflicts ----

  describe('getConflicts', () => {
    it('parses UU lines from porcelain output', async () => {
      mockExecFileAsync.mockResolvedValue({
        stdout: 'UU src/conflict.ts\n M src/clean.ts\n',
        stderr: '',
      })

      const conflicts = await git.getConflicts('/worktree')

      expect(conflicts).toEqual(['src/conflict.ts'])
    })

    it('parses AA and DD lines from porcelain output', async () => {
      mockExecFileAsync.mockResolvedValue({
        stdout: 'AA src/both-added.ts\nDD src/both-deleted.ts\n',
        stderr: '',
      })

      const conflicts = await git.getConflicts('/worktree')

      expect(conflicts).toEqual(['src/both-added.ts', 'src/both-deleted.ts'])
    })

    it('returns empty array for clean status', async () => {
      mockExecFileAsync.mockResolvedValue({ stdout: ' M src/file.ts\n?? new.ts\n', stderr: '' })

      const conflicts = await git.getConflicts('/worktree')

      expect(conflicts).toEqual([])
    })

    it('returns [] on error', async () => {
      mockExecFileAsync.mockRejectedValue(new Error('git failed'))

      const conflicts = await git.getConflicts('/worktree')

      expect(conflicts).toEqual([])
    })
  })

  // ---- resolveConflict ----

  describe('resolveConflict', () => {
    it('validates path traversal and rejects paths outside worktree', async () => {
      await expect(
        git.resolveConflict('/worktree', '../../etc/passwd', 'hacked'),
      ).rejects.toThrow('Path traversal denied')
    })

    it('rejects path with .. traversal', async () => {
      await expect(
        git.resolveConflict('/worktree', '../outside/file.ts', 'content'),
      ).rejects.toThrow('Path traversal denied')
    })

    it('writes file and runs git add for valid paths', async () => {
      mockWriteFile.mockResolvedValue(undefined)
      mockExecFileAsync.mockResolvedValue({ stdout: '', stderr: '' })

      await git.resolveConflict('/worktree', 'src/file.ts', 'resolved content')

      expect(mockWriteFile).toHaveBeenCalledWith(
        expect.stringContaining('src/file.ts'),
        'resolved content',
        'utf-8',
      )
      expect(mockExecFileAsync).toHaveBeenCalledWith(
        'git',
        ['add', '--', 'src/file.ts'],
        { cwd: '/worktree' },
      )
    })

    it('accepts files in nested subdirectories', async () => {
      mockWriteFile.mockResolvedValue(undefined)
      mockExecFileAsync.mockResolvedValue({ stdout: '', stderr: '' })

      await git.resolveConflict('/worktree', 'src/deep/nested/file.ts', 'content')

      expect(mockWriteFile).toHaveBeenCalled()
      expect(mockExecFileAsync).toHaveBeenCalledWith(
        'git',
        ['add', '--', 'src/deep/nested/file.ts'],
        { cwd: '/worktree' },
      )
    })
  })

  // ---- aiGenerate ----

  describe('aiGenerate', () => {
    function createMockChild(stdout: string, exitCode: number) {
      const child = Object.assign(new EventEmitter(), {
        stdout: new EventEmitter(),
        stdin: { write: vi.fn(), end: vi.fn() },
        kill: vi.fn(),
      })
      mockSpawn.mockReturnValue(child)
      process.nextTick(() => {
        if (stdout) child.stdout.emit('data', Buffer.from(stdout))
        child.emit('close', exitCode)
      })
      return child
    }

    it('pipes prompt via stdin and returns trimmed stdout', async () => {
      const child = createMockChild('  generated commit message  \n', 0)

      const result = await git.aiGenerate('/usr/local/bin/claude', 'write a message', '/worktree')

      expect(result).toBe('generated commit message')
      expect(mockSpawn).toHaveBeenCalledWith(
        '/usr/local/bin/claude',
        ['-p'],
        { cwd: '/worktree', stdio: ['pipe', 'pipe', 'pipe'] },
      )
      expect(child.stdin.write).toHaveBeenCalledWith('write a message')
      expect(child.stdin.end).toHaveBeenCalled()
    })

    it('returns empty string on non-zero exit', async () => {
      createMockChild('', 1)

      const result = await git.aiGenerate('/usr/local/bin/claude', 'prompt', '/worktree')

      expect(result).toBe('')
    })

    it('passes extra args after -p flag', async () => {
      createMockChild('ai message\n', 0)

      const result = await git.aiGenerate('/usr/local/bin/claude', 'prompt', '/worktree', ['--model', 'haiku'])

      expect(result).toBe('ai message')
      expect(mockSpawn).toHaveBeenCalledWith(
        '/usr/local/bin/claude',
        ['-p', '--model', 'haiku'],
        { cwd: '/worktree', stdio: ['pipe', 'pipe', 'pipe'] },
      )
    })

    it('returns empty string on spawn error', async () => {
      const child = Object.assign(new EventEmitter(), {
        stdout: new EventEmitter(),
        stdin: { write: vi.fn(), end: vi.fn() },
        kill: vi.fn(),
      })
      mockSpawn.mockReturnValue(child)
      process.nextTick(() => {
        child.emit('error', new Error('ENOENT'))
      })

      const result = await git.aiGenerate('/nonexistent/binary', 'prompt', '/cwd')

      expect(result).toBe('')
    })
  })

  // ---- getPRContext ----

  describe('getPRContext', () => {
    it('returns commits, diffStat, and truncated diffPatch', async () => {
      mockExecFileAsync
        .mockResolvedValueOnce({ stdout: 'abc1234 feat: add login\ndef5678 fix: typo\n', stderr: '' })
        .mockResolvedValueOnce({ stdout: ' src/a.ts | 10 ++++\n src/b.ts |  3 ---\n', stderr: '' })
        .mockResolvedValueOnce({ stdout: 'diff --git a/src/a.ts b/src/a.ts\n+new line\n', stderr: '' })

      const ctx = await git.getPRContext('/worktree', 'main')

      expect(ctx.commits).toBe('abc1234 feat: add login\ndef5678 fix: typo')
      expect(ctx.diffStat).toBe('src/a.ts | 10 ++++\n src/b.ts |  3 ---')
      expect(ctx.diffPatch).toBe('diff --git a/src/a.ts b/src/a.ts\n+new line')
      expect(mockExecFileAsync).toHaveBeenCalledWith(
        'git', ['log', '--oneline', 'main..HEAD'], { cwd: '/worktree' },
      )
      expect(mockExecFileAsync).toHaveBeenCalledWith(
        'git', ['diff', '--stat', 'main..HEAD'], { cwd: '/worktree' },
      )
      expect(mockExecFileAsync).toHaveBeenCalledWith(
        'git', ['diff', 'main..HEAD'], { cwd: '/worktree' },
      )
    })

    it('truncates diffPatch to 6000 chars', async () => {
      const longPatch = 'x'.repeat(8000)
      mockExecFileAsync
        .mockResolvedValueOnce({ stdout: 'abc feat\n', stderr: '' })
        .mockResolvedValueOnce({ stdout: 'stat\n', stderr: '' })
        .mockResolvedValueOnce({ stdout: longPatch, stderr: '' })

      const ctx = await git.getPRContext('/worktree', 'main')

      expect(ctx.diffPatch.length).toBe(6000)
    })

    it('returns empty strings on error', async () => {
      mockExecFileAsync.mockRejectedValue(new Error('not a git repo'))

      const ctx = await git.getPRContext('/worktree', 'main')

      expect(ctx).toEqual({ commits: '', diffStat: '', diffPatch: '' })
    })
  })

  // ---- fetchAndUpdate ----

  describe('fetchAndUpdate', () => {
    it('uses merge --ff-only when base branch is checked out', async () => {
      mockExecFileAsync
        .mockResolvedValueOnce({ stdout: 'abc1234\n', stderr: '' }) // rev-parse before
        .mockResolvedValueOnce({ stdout: '', stderr: '' })          // fetch origin
        .mockResolvedValueOnce({ stdout: 'main\n', stderr: '' })   // symbolic-ref HEAD
        .mockResolvedValueOnce({ stdout: '', stderr: '' })          // merge --ff-only
        .mockResolvedValueOnce({ stdout: 'def5678\n', stderr: '' }) // rev-parse after
        .mockResolvedValueOnce({ stdout: '3\n', stderr: '' })       // rev-list --count

      const result = await git.fetchAndUpdate('/project', 'main')

      expect(result).toEqual({
        updatedBranch: 'main',
        previousRef: 'abc1234',
        currentRef: 'def5678',
        commitCount: 3,
      })
      expect(mockExecFileAsync).toHaveBeenNthCalledWith(
        3, 'git', ['symbolic-ref', '--short', 'HEAD'], { cwd: '/project' },
      )
      expect(mockExecFileAsync).toHaveBeenNthCalledWith(
        4, 'git', ['merge', '--ff-only', 'origin/main'], { cwd: '/project' },
      )
    })

    it('uses fetch origin branch:branch when base branch is not checked out', async () => {
      mockExecFileAsync
        .mockResolvedValueOnce({ stdout: 'abc1234\n', stderr: '' }) // rev-parse before
        .mockResolvedValueOnce({ stdout: '', stderr: '' })          // fetch origin
        .mockResolvedValueOnce({ stdout: 'develop\n', stderr: '' }) // symbolic-ref HEAD (different branch)
        .mockResolvedValueOnce({ stdout: '', stderr: '' })          // fetch origin main:main
        .mockResolvedValueOnce({ stdout: 'def5678\n', stderr: '' }) // rev-parse after
        .mockResolvedValueOnce({ stdout: '3\n', stderr: '' })       // rev-list --count

      const result = await git.fetchAndUpdate('/project', 'main')

      expect(result).toEqual({
        updatedBranch: 'main',
        previousRef: 'abc1234',
        currentRef: 'def5678',
        commitCount: 3,
      })
      expect(mockExecFileAsync).toHaveBeenNthCalledWith(
        4, 'git', ['fetch', 'origin', 'main:main'], { cwd: '/project' },
      )
    })

    it('falls back to fetch origin branch:branch on detached HEAD', async () => {
      mockExecFileAsync
        .mockResolvedValueOnce({ stdout: 'abc1234\n', stderr: '' }) // rev-parse before
        .mockResolvedValueOnce({ stdout: '', stderr: '' })          // fetch origin
        .mockRejectedValueOnce(new Error('not a symbolic ref'))     // symbolic-ref fails (detached)
        .mockResolvedValueOnce({ stdout: '', stderr: '' })          // fetch origin main:main
        .mockResolvedValueOnce({ stdout: 'abc1234\n', stderr: '' }) // rev-parse after
        .mockResolvedValueOnce({ stdout: '0\n', stderr: '' })       // rev-list --count

      const result = await git.fetchAndUpdate('/project', 'main')

      expect(result.commitCount).toBe(0)
      expect(mockExecFileAsync).toHaveBeenNthCalledWith(
        4, 'git', ['fetch', 'origin', 'main:main'], { cwd: '/project' },
      )
    })

    it('returns commitCount 0 when already up to date', async () => {
      mockExecFileAsync
        .mockResolvedValueOnce({ stdout: 'abc1234\n', stderr: '' })
        .mockResolvedValueOnce({ stdout: '', stderr: '' })
        .mockResolvedValueOnce({ stdout: 'main\n', stderr: '' })
        .mockResolvedValueOnce({ stdout: '', stderr: '' })
        .mockResolvedValueOnce({ stdout: 'abc1234\n', stderr: '' })
        .mockResolvedValueOnce({ stdout: '0\n', stderr: '' })

      const result = await git.fetchAndUpdate('/project', 'main')

      expect(result.commitCount).toBe(0)
      expect(result.previousRef).toBe('abc1234')
      expect(result.currentRef).toBe('abc1234')
    })

    it('propagates error when fetch fails', async () => {
      mockExecFileAsync
        .mockResolvedValueOnce({ stdout: 'abc1234\n', stderr: '' })
        .mockRejectedValueOnce(new Error('Could not resolve host'))

      await expect(git.fetchAndUpdate('/project', 'main'))
        .rejects.toThrow('Could not resolve host')
    })

    it('propagates error when fast-forward fails (diverged)', async () => {
      mockExecFileAsync
        .mockResolvedValueOnce({ stdout: 'abc1234\n', stderr: '' })
        .mockResolvedValueOnce({ stdout: '', stderr: '' })
        .mockResolvedValueOnce({ stdout: 'main\n', stderr: '' })
        .mockRejectedValueOnce(new Error('non-fast-forward'))

      await expect(git.fetchAndUpdate('/project', 'main'))
        .rejects.toThrow('non-fast-forward')
    })
  })
})
