import { useState, useEffect, useCallback } from 'react'
import type { FileTreeNode } from '../../shared/types'

interface UseAdditionalDirsResult {
  additionalDirs: string[]
  additionalTrees: Map<string, FileTreeNode>
  refreshTree: (dirPath: string) => Promise<void>
}

export function useAdditionalDirs(activeSessionId: string | null): UseAdditionalDirsResult {
  const [additionalDirs, setAdditionalDirs] = useState<string[]>([])
  const [additionalTrees, setAdditionalTrees] = useState<Map<string, FileTreeNode>>(new Map())

  // Reset when session changes
  useEffect(() => {
    if (!activeSessionId) {
      setAdditionalDirs([])
      setAdditionalTrees(new Map())
      return
    }

    // Load persisted dirs from session data
    window.electronAPI.invoke('agent:sessions').then((sessions: unknown) => {
      const sessionList = sessions as Array<{ id: string; additionalDirs: string[] }>
      const session = sessionList.find((s) => s.id === activeSessionId)
      if (session?.additionalDirs?.length) {
        setAdditionalDirs(session.additionalDirs)
        for (const dir of session.additionalDirs) {
          fetchTree(activeSessionId, dir)
        }
      }
    }).catch(() => {})
  }, [activeSessionId])

  // Listen for new dirs added
  useEffect(() => {
    if (!activeSessionId) return

    const unsub = window.electronAPI.on('agent:dirs-changed', (payload: unknown) => {
      const { sessionId, additionalDirs: dirs } = payload as {
        sessionId: string
        additionalDirs: string[]
      }
      if (sessionId !== activeSessionId) return
      setAdditionalDirs(dirs)

      for (const dir of dirs) {
        fetchTree(activeSessionId, dir)
      }
    })

    return unsub
  }, [activeSessionId])

  // Refresh trees on files:changed with source
  useEffect(() => {
    if (!activeSessionId || additionalDirs.length === 0) return

    const unsub = window.electronAPI.on('files:changed', (payload: unknown) => {
      const { sessionId, source } = payload as { sessionId: string; source?: string }
      if (sessionId !== activeSessionId || !source) return
      if (additionalDirs.includes(source)) {
        fetchTree(activeSessionId, source)
      }
    })

    return unsub
  }, [activeSessionId, additionalDirs])

  function fetchTree(sessionId: string, dirPath: string): void {
    window.electronAPI.invoke('files:tree-dir', sessionId, dirPath).then((tree) => {
      setAdditionalTrees((prev) => {
        const next = new Map(prev)
        next.set(dirPath, tree as FileTreeNode)
        return next
      })
    }).catch(() => {})
  }

  const refreshTree = useCallback(async (dirPath: string) => {
    if (!activeSessionId) return
    fetchTree(activeSessionId, dirPath)
  }, [activeSessionId])

  return { additionalDirs, additionalTrees, refreshTree }
}
